import add_points
import carto2csv
import mat2csv
import argparse
import create_surface
import extract_tags
import mesh_tools
import apply_cv
import tet
import plot
import glob
import os
import time


def run(meshname="carto_meshes/OC44/1-Baseline.mesh", plt=False, save=False, boxplot=False,
        switches="-pYkANEFq1.5/20 -ae+06", refine_steps=10,
        keep_intmed=False, skip_reading=False, HULK=False, mesh_format="carto",
        min_edge=700., max_edge=1400., return_surfacemesh=True, ncv=1, from_stl=False, n_col=1):
    """Reads in .mesh file and writes out a refined tetrahedron mesh in .vtk format and carp format.
    If 'speed.csv' exists in the cwd, also interpolates these speeds on the mesh. speed.csv should be a csv file with
    columns 'x', 'y', 'z' and 'speed', where the xyz coordinates refer to point coordinates. Can be calculated with
    DGM.

    @param meshname: <str> name of the input carto .mesh file
    @param plt: <bool> Plot out the resulting .vtk mesh with PyVista Baseplotter
    @param save: <bool> Plot out the resulting .vtk mesh with PyVista Baseplotter and save figure on exit
    @param refine_steps: <int> amount of refinement steps during the refinement process of the double-layered surface mesh
    @param boxplot: <>bool Make a boxplot of the edgelengths during the refinement procedure of the double-layered
    surface mesh
    @param switches: <str> switches to be used by TetGen
    @param keep_intmed: <bool> keep intermediate files generated by TetGen, carto2csv.py or applycv.py
    @param skip_reading: <bool> skip the conversion of CARTO .mesh files to .csv files
    (useful together with keep_intmed to save time)
    @param HULK: <bool> is script run on the HULK supercomputer or not
    @param mesh_format: <str> Only 'carto' is supported for now
    @param min_edge: <float> minimum allowed edge length for the mesh in µm
    @param max_edge: <float> maximum allowed edge length for the mesh in µm
    @param return_surfacemesh: <bool> stop the tetrahedralisation and return the refined double-layered surface mesh
    instead (for testing purposes)
    @param ncv: <int> amount of different conduction velocity distributions to be made. 1 corresponds with the
    original conduction velocities
    @param from_stl: <bool> Read in .stl file instead of .smesh file. Useful for preprocessing of meshes with e.g. MeshLab
    (not fully implemented yet)
    @param n_col: <int> amount of times TetGen needs to try and fix collinearities before giving up.
    """

    fn = meshname.split(".")[0]  # base filename
    if "/" in meshname:
        meshdir = "/".join(meshname.split("/")[:-1]) + "/"
        print("meshdir: ", meshdir)
    else:
        meshdir = ""

    print("\n####### Creating 3D tetrahedralized {}\n".format(fn))

    step = 1  # progress
    start = time.time()

    def writeCsv(meshname_, meshdir_, mesh_format_="carto", step_=step):
        """Creates separate csv files per section for a carto mesh in the same folder"""
        if mesh_format_ == "carto":
            print("---- {}. Reading CARTO .mesh file and writing to csv\n".format(step_))
            carto2csv.cartoToCsv(meshname_, meshdir_)
        else:
            print("---- {}. Reading Bordeaux .mat file and writing to csv\n".format(step_))
            mat2csv.ply2csv(meshname_)  # assumes there is a .ply file present in the meshdir (see mat2csv.mat2ply())

    def addPoints(meshdir_, from_stl_, step_=step):
        """Calculate normals, create normals.csv and add points outside and inside of mesh
        Creates txt files of outside mesh (epi.txt) and inside mesh (endo.txt) in same directory
        Keeps original mesh as mid.txt (not used in next script create_surface.py)
        Uses previously generated VerticesSection.csv and TrianglesSection.csv"""
        print("\n---- {}. Adding endo and epi point layers\n".format(step_))
        add_points.writePoints(meshdir_, from_stl=from_stl_)

    def makeSmesh(of_=fn, plot_mesh=False, refine_steps_=refine_steps, boxplot_=boxplot, meshdir_=meshdir,
                  min_edge_=min_edge, max_edge_=max_edge):
        """Refines double layered mesh. Writes out to .smesh file
        Returns refined double layered mesh file"""
        print("\n---- {}. Creating refined surface mesh and .smesh file\n".format(step))
        if mesh_format == 'mat':  # TODO: complete .mat format implementation
            steps = 2
        mesh = create_surface.run(of=of_, plot_mesh=plot_mesh, refine_steps=refine_steps_, boxplot=boxplot_,
                                  meshdir=meshdir_, min_edge=min_edge_, max_edge=max_edge_, returnmesh=True)
        extract_tags.colorFromCsv(meshdir_)  # TODO: this is optional and unused in further code
        return mesh

    def tetrahedralise(mesh, filename_=fn, switches_=switches, HULK_=HULK):
        """Reads in .smesh file and tetrahedralises the double layered mesh.
        Checks for collinearities
        @param mesh: the PyVista format double layered refined surface mesh
        @param filename_: The filename of the .smesh file, to be read in by TetGen
        @param switches_: the switches use by TetGen
        @param HULK_: adapts directory names in case the script is run on HULK"""
        print("\n---- {}. Tetrahedralizing .smesh file\n".format(step))
        colinear_pairs = tet.run(filename=filename_, switches=switches_, HULK=HULK_)
        i = 0
        while i < n_col and len(colinear_pairs) > 0:  # check for collinear pairs
            print("\n\tCollinearity found! Adapting points...")
            mesh_ = mesh_tools.makeNonCollinear(mesh, colinear_pairs)
            create_surface.writeSmesh(mesh_, "{}".format(fn))
            tet.run(filename=fn, switches=switches_, HULK=HULK_)
            i += 1

    # Read in the meshes
    if not skip_reading:
        writeCsv(meshname, meshdir, step_=step)
        step += 1

    # Add second layer of points and triangles
    addPoints(meshdir, from_stl_=from_stl, step_=step)
    step += 1

    # Refine, make .smesh file
    double_layered_mesh = makeSmesh(of_=fn, plot_mesh=False, boxplot_=boxplot, meshdir_=meshdir,
                                    min_edge_=min_edge, max_edge_=max_edge)
    if return_surfacemesh:  # stop tetrahedralisation process and return double layered surface mesh instead
        return double_layered_mesh
    # create_surface adapted filename to form: basefilename + "_<minedge>-<maxedge>µm"
    fn += '_{}-{}µm'.format(int(min_edge), int(max_edge))
    step += 1

    # Make tetrahedrons from double-layered refined surface mesh
    tetrahedralise(double_layered_mesh, filename_=fn, switches_=switches, HULK_=HULK)
    step += 1

    if plt:
        print('\tPlotting...')
        plot.run(fn + ".1.vtk")
    elif save:
        print('\tPlotting...')
        plot.run(fn + ".1.vtk", save=True)
    print('\n\tTetrahedralizing done.')

    print("\n---- {}. Converting to carp and paraview-friendly format\n".format(step))
    mesh_tools.convertMesh_Meshtool(fn)  # by default vtk to carp_txt
    # pts2paraview.convert(fn + '.pts')
    step += 1

    # clean created mesh
    print("\n---- {}. Cleaning with meshtool\n".format(step))
    mesh_tools.cleanMesh_Meshtool(fn, .2)
    print('\n\tAdapting .vtk ...')
    mesh_tools.convertMesh_Meshtool(fn, ifmt='carp_txt',
                                    ofmt='vtk')  # Make sure .vtk file is same as carp file after cleaning
    step += 1

    if ncv:
        print("\n---- {}. Applying conduction velocities\n".format(step))
        apply_cv.run(meshdir, fn + '.1.vtk', write_VTK_file=True, n_variations=ncv)
        step += 1

    if not keep_intmed:  # delete intermediate files
        print("\n----- {}. Deleting intermediate files\n".format(step))
        # remove intermediate files that weren't present before generating and aren't the .vtk file
        to_delete = ["mid.txt", "endo.txt", "epi.txt", "TrianglesSection.csv", "VerticesSection.csv",
                     fn + ".smesh", fn + '.mtr', fn + '.1.mtr', fn + '.1.p2t', fn + '.1.node', fn + '.1.edge',
                     fn + '.1.face', fn + '.1.ele', 'VerticesAttributesSection.csv',
                     'VerticesColorsSection.csv', 'myo.csv', 'noncond.csv', 'Surface.stl']
        for trash in to_delete:
            if glob.glob(trash):
                os.remove(trash)
                print("\tDeleted ", trash)
        step += 1

    duration = time.time() - start
    print("\n\tDone in {0}m {1:.2f}s".format(int(duration // 60), duration % 60))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)
    # fetching the arguments
    parser.add_argument('--filename',
                        help="Input carto file, including .mesh format. Default is first .mesh file in cwd.",
                        type=str, default=None)
    parser.add_argument('--switches',
                        help="switches to use for tetgen command.\n"
                             "-p  For tetrahedralization\n"
                             "-Y  for preserving input faces as boundaries\n"
                             "-k  Outputs mesh to .vtk file for viewing by Paraview\n"
                             "-A  Assigns region attributes (i.e. conductivity regions)\n"
                             "-N  Suppresses creation of .node file\n"
                             "-E  Suppresses creation of .ele file\n"
                             "-F  Suppresses creation of .face file\n"
                             "-q  +minRadiusEdgeRatio/minDihAngle - Refines mesh (improves quality)\n"
                             "-a  +volume - Volume constraint in µm³ (default = 2.0e+08)\n"
                             "-m  Uses mesh sizing function for edge lengths"
                             "    Don't go too much finer. This already yields O(e+05) steiner points\n"
                             "-V  (optional) for verbose output\n"
                             "-O  Optimisation level: flip level/local optimisation/maximum iterations\n"
                             "    0-10/0-7/inf    default: 3/7/3"
                             "(Mesh quality statistics, edge lengths, volumes...)\n\n",
                        type=str, default="-pYkAmNEFq2.5/20a2e+6")
    # The volumes of a quality mesh are on average 2e06 µm³ +/- 1e06 µm³ (max 3e7 is recommended)

    parser.add_argument('--p',
                        help="Add this optional argument to open interactive vtk window\nshowing a plot"
                             "of the tetrahedralized mesh.", nargs='?',
                        default=False, const=True)
    parser.add_argument('--ps',
                        help="Add this optional argument to open interactive vtk window\nshowing a plot"
                             "of the tetrahedralized mesh\nand save the plot on exit.", nargs='?',
                        default=False, const=True)
    parser.add_argument('--er',
                        help="Desired Edge Range of the mesh. Min and max value, separated by a \"-\".\n"
                             "Default = 500-1100 µm", default="500-1100")
    parser.add_argument('--steps',
                        help="Amount of refinement steps taken. Should be sufficiently large for fine meshes.",
                        default=10, type=int)
    parser.add_argument('--ki',
                        help="Add this optional argument to keep intermediately\n"
                             "created files during tetrahedralisation process."
                             "of the tetrahedralized mesh.", nargs='?',
                        default=False, const=True)
    parser.add_argument("--sr",
                        help="Skip reading carto mesh and .txt file\n"
                             "Assumes .csv and .txt files are already present (hint: use --ki)",
                        default=False, const=True, nargs='?')
    parser.add_argument("--format",
                        help="File format (str): \"carto\" or \"mat\"",
                        type=str, default="carto")
    parser.add_argument("--boxplot",
                        help="create boxplot of edgelengths during mesh refinement procedure",
                        default=False, const=True, nargs="?")
    parser.add_argument('--nvar',
                        help='Amount of conduction velocity variations.\n'
                             'First variation is always the reconstruction\n'
                             ' of the actual distribution.',
                        type=int, default=1)
    parser.add_argument('--HULK',
                        help='Add this argument if you\'re running on HULK',
                        nargs='?', default=False, const=True)
    parser.add_argument('--stl', help='If file should be read from \'Surface.stl\'',
                        nargs='?', default=False, const=True)
    parser.add_argument('--col_retry',
                        help='Amount of times the colinearity will be fixed (or attempt to do so).',
                        type=int, default=1)
    parser.add_argument('--ncv',
                        help='Amount of conduction velocity variations.\n'
                             'First variation is always the reconstruction\n'
                             ' of the original distribution.',
                        type=int, default=0)
    args = parser.parse_args()
    if not args.filename:  # no filename given
        if args.format == "carto":
            filename = glob.glob("*.mesh")[0]  # pick first .mesh file
        else:  # format = mat
            filename = glob.glob("*.mat")[0]  # pick first .mat file
    else:
        filename = args.filename

    switches = args.switches
    # if args.ki:
    #     for switch in ["N", "E", "F"]:
    #         switches = switches.replace(switch, "")  # write out node, face and edge files

    min_edge, max_edge = [float(e) for e in args.er.split("-")]

    run(meshname=filename, switches=switches, plt=args.p, save=args.ps, keep_intmed=args.ki, skip_reading=args.sr,
        mesh_format=args.format, min_edge=min_edge, max_edge=max_edge, refine_steps=args.steps,
        boxplot=args.boxplot, return_surfacemesh=False, ncv=args.ncv, HULK=args.HULK, from_stl=args.stl,
        n_col=args.col_retry)
