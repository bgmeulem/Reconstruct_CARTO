import pandas as pd
import numpy as np
import pyvista as pv
from tqdm import tqdm
from mesh_tools import pvToPmFaces


def normalize(vector):
    return [e / np.sqrt(np.dot(vector, vector)) for e in vector]


def readMesh(meshdir="", from_stl=False):
    """Reads in .csv files as generated by carto2csv
    if from_stl == True, then point and triangle info is read from .stl file
    Currently, from_stl is not fully implemented yet"""
    if from_stl:
        mesh = pv.read("test.stl")
        mesh.compute_normals(inplace=True)
        vert = pd.DataFrame(mesh.points, columns=[['X', 'Y', 'Z']])
        tri = pd.DataFrame(pvToPmFaces(mesh.faces), columns=[['Vertex0', 'Vertex1', 'Vertex2']])
        tri[["NormalX", "NormalY", "NormalZ"]] = pd.DataFrame(mesh["Normals"], index=tri.index)
        tri["GroupID"] = mesh.n_faces * [0]  # ignore GroupID
        tri.to_csv("TrianglesSection.csv")
        vert.to_csv("VerticesSection.csv")
    else:
        vert = pd.read_csv(meshdir + "VerticesSection.csv", sep=',')
        tri = pd.read_csv(meshdir + 'TrianglesSection.csv', sep=',')
    return vert, tri


def calcAvNormal(facets):
            """Calculates the average normal of a dataframe of triangles. Dataframe must contain
            the components of the normals of each triangle in columns named 'NormalX', 'NormalY', 'NormalZ'
            as is the case for Carto data"""
            av_normal = [0, 0, 0]
            # loop over all facets and calculate average normal
            for row in facets[['NormalX', 'NormalY', 'NormalZ', 'GroupID']].iterrows():
                for i in range(len(av_normal)):  # from 0 to 2
                    av_normal[i] += row[1][i]
            av_normal = normalize(av_normal)
            return av_normal


def writePoints(meshdir="", from_stl=False, thickness=.5, ratio=.8):
    """Reads in .csv files from carto2csv.py, calculates normals of mesh facets and adds two layers of points
    along these normals: the epi- and endocardium.
    @param meshdir: <str> directory where the carto .mesh file is
    @param from_stl: <bool> whether or not the input mesh is .stl format (instead of carto)
    @param thickness: <float> desired thickness of the mesh. #TODO: only .5mm has been tested"""
    vert, tri = readMesh(meshdir, from_stl)
    endo = open(meshdir + 'endo.txt', 'w+')
    epi = open(meshdir + 'epi.txt', 'w+')
    for f in (endo, epi):
        f.write(meshdir + "Index,X,Y,Z\n")
    tqbar = tqdm(range(vert.shape[0]), desc='        Adding points')
    for index, point in vert.iterrows():
        tqbar.update(1)
        co = point[['X', 'Y', 'Z']]

        # Select all facets that uses the vertex (usually each vertex appears in  ~5 triangles)
        facets_ = tri.loc[(tri[['Vertex0']].values == index) | (tri[['Vertex1']].values == index) |
                          (tri[['Vertex2']].values == index)]

        av_normal = calcAvNormal(facets_)
        outside = ratio*thickness
        inside = (1-ratio)*thickness
        newpoint = [e + outside * n for e, n in zip(co, av_normal)]
        newpoint2 = [e - inside * n for e, n in zip(co, av_normal)]

        for f, p in zip((endo, epi), (newpoint2, newpoint)):  # loop over files and corresponding points
            f.write(str(index))
            for comp in p:  # components of point
                f.write(',' + str(comp * 1000.))  # Convert from mm to Âµm and write out
            f.write('\n')

    endo.close()
    epi.close()
    tqbar.close()


if __name__ == '__main__':
    writePoints()
